<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EREN AGI Core | Neural Interface v2.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
            --bg-dark: #050508;
            --panel-bg: rgba(10, 15, 25, 0.65);
            --border-glow: 0 0 10px rgba(0, 243, 255, 0.3);
            --text-glow: 0 0 5px rgba(0, 243, 255, 0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            color: var(--primary);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            background: radial-gradient(circle at center, #0a0a12 0%, #000000 100%);
        }

        /* Scanline Effect */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            padding: 25px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-panel {
            background: var(--panel-bg);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-left: 3px solid var(--primary);
            padding: 20px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            pointer-events: auto;
            max-width: 380px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 243, 255, 0.05);
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%);
            transition: all 0.3s ease;
            animation: slideIn 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .hud-panel:hover {
            border-color: var(--primary);
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 243, 255, 0.1);
        }

        @keyframes slideIn {
            from {
                transform: translateX(-50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        h1 {
            font-size: 24px;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 700;
            text-shadow: var(--text-glow);
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2 {
            font-size: 14px;
            color: #fff;
            margin: 15px 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
        }

        h2::before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            background: var(--secondary);
            margin-right: 8px;
            box-shadow: 0 0 5px var(--secondary);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .stat-value {
            color: var(--primary);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .bar-container {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px var(--primary);
        }

        /* Interactive Controls */
        .control-group {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid rgba(0, 243, 255, 0.4);
            color: var(--primary);
            padding: 10px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.2), transparent);
            transition: 0.5s;
        }

        button:hover {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--primary);
        }

        button:hover::before {
            left: 100%;
        }

        button:active {
            background: var(--primary);
            color: #000;
        }

        button.danger {
            border-color: #ff2a6d;
            color: #ff2a6d;
        }

        button.danger:hover {
            background: rgba(255, 42, 109, 0.15);
            border-color: #ff2a6d;
            box-shadow: 0 0 15px rgba(255, 42, 109, 0.2);
            text-shadow: 0 0 5px #ff2a6d;
        }

        /* Module Grid */
        .module-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
        }

        .module-box {
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            text-align: center;
            font-size: 11px;
            color: #666;
            transition: 0.3s;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .mod-mem.active {
            background: rgba(0, 136, 255, 0.2);
            color: #0088ff;
            border-color: #0088ff;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.3);
        }

        .mod-learn.active {
            background: rgba(0, 255, 204, 0.2);
            color: #00ffcc;
            border-color: #00ffcc;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .mod-pfc.active {
            background: rgba(255, 0, 255, 0.2);
            color: #ff00ff;
            border-color: #ff00ff;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }

        .mod-sim.active {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
            border-color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(5, 5, 10, 0.9);
            border: 1px solid var(--primary);
            color: #fff;
            padding: 10px 15px;
            font-size: 12px;
            display: none;
            pointer-events: none;
            z-index: 20;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        #tooltip strong {
            color: var(--primary);
            display: block;
            margin-bottom: 3px;
            font-size: 14px;
        }

        /* Log Console */
        #log-console {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 400px;
            height: 150px;
            overflow: hidden;
            border-left: 2px solid var(--primary);
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            padding: 15px;
            display: flex;
            flex-direction: column-reverse;
            pointer-events: none;
            mask-image: linear-gradient(to bottom, transparent, black 20%);
        }

        .log-entry {
            margin-top: 4px;
            padding-left: 10px;
            border-left: 1px solid transparent;
            transition: all 0.2s;
        }

        .log-entry.new {
            color: var(--primary);
            border-left-color: var(--primary);
            text-shadow: 0 0 5px var(--primary);
        }

        #top-right {
            position: absolute;
            top: 25px;
            right: 25px;
            text-align: right;
            pointer-events: none;
        }

        .blink {
            animation: blinker 1.5s infinite;
            color: #ff2a6d;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }

        /* Canvas Graph */
        #graph-canvas {
            width: 100%;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Post Processing (Optional but good for bloom if needed later, keeping simple for now) -->
</head>

<body>

    <div id="canvas-container"></div>
    <div id="tooltip"></div>

    <div id="ui-layer">
        <!-- Control Panel -->
        <div class="hud-panel">
            <h1>EREN AGI CORE <span class="blink">‚óè</span></h1>

            <div class="stat-row"><span>SYSTEM STATUS</span><span id="sys-status" class="stat-value"
                    style="color:#00ff88">ONLINE</span></div>
            <div class="stat-row"><span>ACTIVE NODES</span><span id="active-cells" class="stat-value">0 / 150</span>
            </div>
            <div class="stat-row"><span>NET COHERENCE</span><span id="coherence-val" class="stat-value">0.00%</span>
            </div>

            <div class="bar-container">
                <div id="coherence-bar" class="bar-fill"></div>
            </div>

            <!-- Dynamic Graph -->
            <canvas id="graph-canvas" width="300" height="40"></canvas>

            <!-- Focused Cell Info -->
            <div id="focus-panel"
                style="border-top: 1px solid rgba(255,255,255,0.1); margin-top:10px; padding-top:5px;">
                <h2>NEURAL INSPECTOR</h2>
                <div class="stat-row"><span>NODE ID</span><span id="focus-id" class="stat-value">--</span></div>
                <div class="stat-row"><span>ACTIVATION</span><span id="focus-act" class="stat-value">--</span></div>

                <div class="module-grid">
                    <div id="disp-mem" class="module-box mod-mem">MEMORY</div>
                    <div id="disp-learn" class="module-box mod-learn">LEARN</div>
                    <div id="disp-pfc" class="module-box mod-pfc">LOGIC</div>
                    <div id="disp-sim" class="module-box mod-sim">SIMULATE</div>
                </div>
            </div>

            <!-- Interactions -->
            <div class="control-group">
                <h2>SIGNAL INJECTION</h2>
                <div class="btn-grid">
                    <button onclick="injectSignal('sensory')">SENSORY STREAM</button>
                    <button onclick="injectSignal('logic')">LOGIC PROTOCOL</button>
                    <button onclick="injectSignal('recall')">DEEP RECALL</button>
                    <button onclick="resetSim()" class="danger">SYSTEM RESET</button>
                </div>
            </div>

            <div class="control-group">
                <h2>TOPOLOGY</h2>
                <button onclick="rewireNetwork()" style="width:100%">INITIATE REWIRING SEQUENCE</button>
            </div>

            <p
                style="margin-top:15px; font-size:10px; color:rgba(255,255,255,0.3); text-align:center; letter-spacing:1px;">
                EREN LABS // PROTOTYPE v2.4
            </p>
        </div>

        <div id="top-right">
            <h1 style="border:none; color: rgba(255,255,255,0.1); font-size: 42px; margin:0;">CORE VIEW</h1>
            <p style="color: var(--primary); letter-spacing: 2px; font-size: 12px;">DISTRIBUTED NEURAL ARCHITECTURE</p>
        </div>

        <div id="log-console">
            <div class="log-entry new"> > System Initialized. Awaiting Input...</div>
        </div>
    </div>

    <script>
        // --- 1. AGI CORE LOGIC ---

        const CONFIG = {
            cellCount: 180, // Increased for density
            connectionRadius: 22,
            rewireProb: 0.12,
            decay: 0.96
        };

        class AGICell {
            constructor(id, x, y, z) {
                this.id = id;
                this.pos = new THREE.Vector3(x, y, z);
                this.connections = [];
                this.activation = 0.0;
                this.targetActivation = 0.0;

                // Module Bias (0-1)
                this.modules = {
                    memory: 0.25,
                    learning: 0.25,
                    pfc: 0.25,
                    sim: 0.25
                };

                this.dominantModule = 'learning';
            }

            processInput(type, strength) {
                this.targetActivation = Math.min(this.targetActivation + strength, 1.5);

                switch (type) {
                    case 'sensory':
                        this.biasModules(0.3, 0.5, 0.1, 0.1);
                        this.dominantModule = 'learning';
                        break;
                    case 'logic':
                        this.biasModules(0.1, 0.1, 0.5, 0.3);
                        this.dominantModule = 'pfc';
                        break;
                    case 'recall':
                        this.biasModules(0.6, 0.1, 0.1, 0.2);
                        this.dominantModule = 'memory';
                        break;
                    default:
                        this.biasModules(0.25, 0.25, 0.25, 0.25);
                }
            }

            biasModules(mem, learn, pfc, sim) {
                const rate = 0.2;
                this.modules.memory = THREE.MathUtils.lerp(this.modules.memory, mem, rate);
                this.modules.learning = THREE.MathUtils.lerp(this.modules.learning, learn, rate);
                this.modules.pfc = THREE.MathUtils.lerp(this.modules.pfc, pfc, rate);
                this.modules.sim = THREE.MathUtils.lerp(this.modules.sim, sim, rate);
            }

            update() {
                this.activation = THREE.MathUtils.lerp(this.activation, this.targetActivation, 0.15);
                this.targetActivation *= CONFIG.decay;

                if (this.activation < 0.01) {
                    this.activation = 0;
                    this.targetActivation = 0;
                }
            }
        }

        let cells = [];
        let packets = []; // Data packets for visualization

        // --- 2. THREE.JS VISUALIZATION ---

        let scene, camera, renderer, controls;
        let cellMesh, lineMesh;
        let raycaster, mouse;
        let hoveredIndex = -1;
        let clock = new THREE.Clock();

        // Color Palettes
        const COLORS = {
            base: new THREE.Color(0x112233),
            memory: new THREE.Color(0x0088ff),
            learning: new THREE.Color(0x00ffcc),
            pfc: new THREE.Color(0xff00ff),
            sim: new THREE.Color(0xffaa00)
        };

        function init() {
            const container = document.getElementById('canvas-container');

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.008);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 40, 70);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            const pLight = new THREE.PointLight(0x00f3ff, 1.5, 150);
            pLight.position.set(0, 30, 30);
            scene.add(pLight);

            const pLight2 = new THREE.PointLight(0xbc13fe, 1, 150);
            pLight2.position.set(-30, -20, -30);
            scene.add(pLight2);

            addProceduralEnvironment();
            generateCells();
            generateConnections();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseClick);

            animate();
            log("System Visualizer v2.0 Initialized.");
        }

        function addProceduralEnvironment() {
            // Grid Floor
            const gridHelper = new THREE.PolarGridHelper(120, 16, 8, 64, 0x004433, 0x001111);
            gridHelper.position.y = -50;
            scene.add(gridHelper);

            // Ceiling Grid (Mirror)
            const gridHelper2 = new THREE.PolarGridHelper(120, 16, 8, 64, 0x110022, 0x050011);
            gridHelper2.position.y = 50;
            gridHelper2.rotation.x = Math.PI;
            scene.add(gridHelper2);

            // Particles
            const partGeo = new THREE.BufferGeometry();
            const partPos = [];
            for (let i = 0; i < 600; i++) {
                partPos.push((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400);
            }
            partGeo.setAttribute('position', new THREE.Float32BufferAttribute(partPos, 3));
            const partMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.8, transparent: true, opacity: 0.3 });
            scene.add(new THREE.Points(partGeo, partMat));
        }

        function generateCells() {
            cells = [];
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const col = [];
            const sizes = [];

            for (let i = 0; i < CONFIG.cellCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / CONFIG.cellCount);
                const theta = Math.sqrt(CONFIG.cellCount * Math.PI) * phi;
                const r = 30 + (Math.random() * 10);

                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);

                cells.push(new AGICell(i, x, y, z));
                pos.push(x, y, z);
                col.push(0.1, 0.2, 0.3);
                sizes.push(1.0);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const spriteMap = new THREE.CanvasTexture(createDotCanvas());

            const mat = new THREE.PointsMaterial({
                size: 4.0,
                vertexColors: true,
                map: spriteMap,
                alphaTest: 0.05,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            cellMesh = new THREE.Points(geo, mat);
            scene.add(cellMesh);
        }

        function generateConnections() {
            if (lineMesh) scene.remove(lineMesh);

            const pos = [];
            cells.forEach((c1, i) => {
                c1.connections = [];
                cells.forEach((c2, j) => {
                    if (i <= j) return;
                    const d = c1.pos.distanceTo(c2.pos);
                    if (d < CONFIG.connectionRadius || Math.random() < CONFIG.rewireProb / 10) {
                        c1.connections.push(c2);
                        c2.connections.push(c1);
                        pos.push(c1.pos.x, c1.pos.y, c1.pos.z);
                        pos.push(c2.pos.x, c2.pos.y, c2.pos.z);
                    }
                });
            });

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

            const mat = new THREE.LineBasicMaterial({
                color: 0x00ccaa,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            lineMesh = new THREE.LineSegments(geo, mat);
            scene.add(lineMesh);
            log(`Topology Rebuilt: ${pos.length / 2} Synaptic Links.`);
        }

        // --- 3. ANIMATION LOOP ---

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = clock.getElapsedTime();

            const colors = cellMesh.geometry.attributes.color.array;
            const sizes = cellMesh.geometry.attributes.size; // We'd need a custom shader for per-particle size, but PointsMaterial uses uniform size. 
            // Actually, PointsMaterial DOES NOT support per-vertex size without a custom shader. 
            // We'll stick to color intensity for now to simulate size/glow.

            let activeCount = 0;
            let totalAct = 0;

            // Update Cells
            cells.forEach((cell, i) => {
                cell.update();

                if (cell.activation > 0.1) {
                    activeCount++;
                    totalAct += cell.activation;

                    // Spawn Packet
                    if (Math.random() < 0.05 && cell.connections.length > 0) {
                        const target = cell.connections[Math.floor(Math.random() * cell.connections.length)];
                        spawnPacket(cell.pos, target.pos, cell.dominantModule);

                        // Propagate logic
                        if (Math.random() < 0.2) {
                            target.processInput(cell.dominantModule, cell.activation * 0.2);
                        }
                    }
                }

                // Visual Update
                const cIdx = i * 3;
                const base = COLORS.base;
                const target = COLORS[cell.dominantModule] || COLORS.learning;

                // Pulse effect
                const pulse = Math.sin(time * 5 + i) * 0.1 + 0.9;
                const act = Math.min(cell.activation * pulse, 1.0);

                const r = THREE.MathUtils.lerp(base.r, target.r, act);
                const g = THREE.MathUtils.lerp(base.g, target.g, act);
                const b = THREE.MathUtils.lerp(base.b, target.b, act);

                if (i === hoveredIndex) {
                    colors[cIdx] = 1.0; colors[cIdx + 1] = 1.0; colors[cIdx + 2] = 1.0;
                } else {
                    colors[cIdx] = r; colors[cIdx + 1] = g; colors[cIdx + 2] = b;
                }
            });

            cellMesh.geometry.attributes.color.needsUpdate = true;

            // Update Packets
            updatePackets();

            // Pulse lines
            if (lineMesh) lineMesh.material.opacity = 0.05 + (totalAct / CONFIG.cellCount) * 0.2;

            updateUI(activeCount, totalAct);
            renderer.render(scene, camera);
        }

        // Packet System for "Information Transfer"
        function spawnPacket(start, end, type) {
            // Simple particle moving from A to B
            const color = COLORS[type];
            const geometry = new THREE.BufferGeometry().setFromPoints([start]);
            const material = new THREE.PointsMaterial({ color: color, size: 2, blending: THREE.AdditiveBlending, transparent: true });
            const point = new THREE.Points(geometry, material);

            scene.add(point);
            packets.push({
                mesh: point,
                start: start.clone(),
                end: end.clone(),
                progress: 0,
                speed: 0.05 + Math.random() * 0.05
            });
        }

        function updatePackets() {
            for (let i = packets.length - 1; i >= 0; i--) {
                const p = packets[i];
                p.progress += p.speed;

                if (p.progress >= 1) {
                    scene.remove(p.mesh);
                    packets.splice(i, 1);
                } else {
                    const pos = new THREE.Vector3().lerpVectors(p.start, p.end, p.progress);
                    p.mesh.geometry.setFromPoints([pos]);
                    p.mesh.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        // --- 4. INTERACTION ---

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(cellMesh);

            if (intersects.length > 0) {
                const idx = intersects[0].index;
                if (hoveredIndex !== idx) {
                    hoveredIndex = idx;
                    document.body.style.cursor = 'pointer';
                    controls.autoRotate = false;
                    updateTooltip(event.clientX, event.clientY, idx);
                    updateFocusPanel(cells[idx]);
                }
            } else {
                hoveredIndex = -1;
                document.body.style.cursor = 'default';
                controls.autoRotate = true;
                hideTooltip();
            }
        }

        function onMouseClick() {
            if (hoveredIndex !== -1) {
                cells[hoveredIndex].processInput('logic', 1.0);
                log(`Manual Override: Node ${cells[hoveredIndex].id} Triggered.`);
                spawnRipple(cells[hoveredIndex].pos);
            }
        }

        function spawnRipple(pos) {
            // Visual flair for clicks
            // For now just a log, can add ring effect later
        }

        // --- 5. UI & GRAPH ---

        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');
        let graphData = new Array(50).fill(0);

        function updateUI(active, total) {
            document.getElementById('active-cells').innerText = `${active} / ${CONFIG.cellCount}`;
            const coh = Math.min((total / 15) * 100, 100).toFixed(1);
            document.getElementById('coherence-val').innerText = `${coh}%`;
            document.getElementById('coherence-bar').style.width = `${coh}%`;

            // Update Graph
            graphData.shift();
            graphData.push(parseFloat(coh));
            drawGraph();
        }

        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            graphCtx.clearRect(0, 0, w, h);

            graphCtx.beginPath();
            graphCtx.strokeStyle = '#00f3ff';
            graphCtx.lineWidth = 2;

            for (let i = 0; i < graphData.length; i++) {
                const x = (i / (graphData.length - 1)) * w;
                const y = h - (graphData[i] / 100) * h;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Fill
            graphCtx.lineTo(w, h);
            graphCtx.lineTo(0, h);
            graphCtx.fillStyle = 'rgba(0, 243, 255, 0.1)';
            graphCtx.fill();
        }

        function updateFocusPanel(cell) {
            document.getElementById('focus-id').innerText = `NODE_${cell.id.toString().padStart(3, '0')}`;
            document.getElementById('focus-act').innerText = cell.activation.toFixed(3);
            document.querySelectorAll('.module-box').forEach(el => el.classList.remove('active'));
            const m = cell.modules;
            if (m.memory > 0.3) document.getElementById('disp-mem').classList.add('active');
            if (m.learning > 0.3) document.getElementById('disp-learn').classList.add('active');
            if (m.pfc > 0.3) document.getElementById('disp-pfc').classList.add('active');
            if (m.sim > 0.3) document.getElementById('disp-sim').classList.add('active');
        }

        function updateTooltip(x, y, idx) {
            const el = document.getElementById('tooltip');
            el.style.display = 'block';
            el.style.left = x + 20 + 'px';
            el.style.top = y + 20 + 'px';
            el.innerHTML = `<strong>NODE ${idx}</strong>TYPE: ${cells[idx].dominantModule.toUpperCase()}<br>ACT: ${(cells[idx].activation * 100).toFixed(0)}%`;
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function log(msg) {
            const box = document.getElementById('log-console');
            const d = document.createElement('div');
            d.className = 'log-entry new';
            d.innerText = `> ${msg}`;
            box.prepend(d);

            // Remove 'new' class after animation
            setTimeout(() => d.classList.remove('new'), 2000);

            if (box.children.length > 8) box.lastChild.remove();
        }

        // --- PUBLIC FUNCTIONS ---

        window.injectSignal = function (type) {
            const count = 12;
            log(`INJECTING STREAM: [${type.toUpperCase()}]`);
            for (let i = 0; i < count; i++) {
                const rnd = Math.floor(Math.random() * CONFIG.cellCount);
                cells[rnd].processInput(type, 0.9);
            }
        }

        window.rewireNetwork = function () {
            log("INITIATING TOPOLOGY RECONFIGURATION...");
            generateConnections();
        }

        window.resetSim = function () {
            cells.forEach(c => {
                c.activation = 0;
                c.targetActivation = 0;
            });
            log("SYSTEM PURGE COMPLETE.");
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createDotCanvas() {
            const c = document.createElement('canvas');
            c.width = 64; c.height = 64;
            const ctx = c.getContext('2d');

            const grd = ctx.createRadialGradient(32, 32, 2, 32, 32, 30);
            grd.addColorStop(0, "rgba(255,255,255,1)");
            grd.addColorStop(0.4, "rgba(255,255,255,0.5)");
            grd.addColorStop(1, "rgba(255,255,255,0)");

            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            return c;
        }

        window.onload = init;
    </script>
</body>

</html>